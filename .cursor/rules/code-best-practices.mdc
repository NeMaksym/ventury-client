---
description: 
globs: 
alwaysApply: true
---
# General Code Best Practices

This document outlines fundamental best practices to ensure code quality, readability, and maintainability across the project.

## 1. Readability and Clarity
- **Consistent Styling:** Adhere to a consistent coding style. Utilize the project's Prettier configuration (`.prettierrc`) for automated formatting.
- **Meaningful Naming:** Employ clear and descriptive names for variables, functions, classes, and components. Names should reveal intent.
- **Concise Comments:** Write comments to explain non-obvious logic or complex sections. Avoid over-commenting or stating the obvious.
- **Focused Units:** Keep functions, methods, and classes small and focused on a single responsibility (Single Responsibility Principle - SRP from SOLID).

## 2. Design Principles
- **KISS (Keep It Simple, Stupid):** Prioritize simple, straightforward solutions over unnecessarily complex ones.
- **DRY (Don't Repeat Yourself):** Avoid code duplication. Encapsulate and reuse common logic in functions or modules.
- **SOLID Principles:** While SRP is highlighted above, strive to understand and apply other SOLID principles where appropriate:
    - **O**pen/Closed Principle: Software entities should be open for extension, but closed for modification.
    - **L**iskov Substitution Principle: Subtypes must be substitutable for their base types.
    - **I**nterface Segregation Principle: Clients should not be forced to depend on interfaces they do not use.
    - **D**ependency Inversion Principle: Depend upon abstractions, not concretions.
- **Modularity:** Design modular code. Break down complex systems into smaller, independent, and reusable parts.
- **Avoid Premature Optimization:** Write clear code first. Optimize only when performance bottlenecks are identified through profiling.

## 3. Maintainability
- **Understandability:** Write code that is easy for others (and your future self) to understand.
- **Testability:** Design code that is easy to test. Consider testability from the outset.
- **Refactor Regularly:** Don't be afraid to refactor code to improve its structure, readability, or performance as the system evolves.

## Examples

### Good Example: Clear, Focused, and Reusable
```typescript
// Adheres to SRP, good naming
function calculateItemSubtotal(price: number, quantity: number): number {
  return price * quantity;
}

function calculateCartTotal(items: Array<{ price: number; quantity: number }>): number {
  let total = 0;
  for (const item of items) {
    total += calculateItemSubtotal(item.price, item.quantity); // DRY - uses helper
  }
  return total;
}
```

### Bad Example: Unclear, Monolithic
```typescript
// Violates SRP, poor naming, hard to test
function handleOrder(data: any[]): string {
  let val = 0;
  for (let i = 0; i < data.length; i++) { // Unclear variables 'val', 'p', 'q'
    val += data[i].p * data[i].q;
  }
  // ... imagine more complex, unrelated logic mixed in here ...
  if (val > 100) {
    // ... more logic ...
    return "ProcessedHighValue";
  } else {
    // ... other logic ...
    return "ProcessedLowValue";
  }
}
```
