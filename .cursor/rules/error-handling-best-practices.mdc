---
description: This rule explains how to handle errors in the codebase.
globs: **/*.ts,**/*.tsx
alwaysApply: false
---
# Error Handling Best Practices

Consistent and clear error handling improves code robustness and debuggability.

1.  **Use Specific Error Types**:
    *   Avoid generic `Error` objects when a more specific error type can be used or created. This helps in distinguishing different error scenarios.
    *   Example: `class NetworkError extends Error { constructor(message) { super(message); this.name = "NetworkError"; } }`

2.  **Handle Errors Locally or Propagate Clearly**:
    *   Handle errors as close to the source as possible if the context is sufficient.
    *   If an error cannot be handled locally, propagate it up the call stack. Ensure the propagated error includes enough context or is wrapped in a more specific error type if necessary.
    *   Avoid swallowing errors silently (e.g., empty `catch` blocks).

3.  **User-Facing Errors**:
    *   Provide clear, user-friendly error messages for errors that will be displayed to the user. Avoid exposing technical details or stack traces directly.
    *   Log detailed technical errors for debugging purposes separately.

4.  **Async Operations**:
    *   Always handle potential errors in Promises (using `.catch()`) and async/await (using `try...catch` blocks).
    *   Ensure all promise chains have a final catch handler to prevent unhandled promise rejections.

5.  **Input Validation**:
    *   Validate inputs at the boundaries of your system/modules (e.g., API inputs, function arguments from untrusted sources).
    *   Throw or return specific validation errors.

6.  **Logging**:
    *   Log errors with sufficient context (e.g., relevant variables, operation being performed, timestamp).
    *   Use appropriate log levels (e.g., ERROR, WARN).

Example:
```typescript
// Good example
async function fetchData(url: string): Promise<Data> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      // Log the technical error
      console.error(`API Error: ${response.status} ${response.statusText} for URL: ${url}`);
      // Throw a more specific or user-friendly error if needed for upstream handlers
      throw new Error('Failed to fetch data. Please try again later.');
    }
    return await response.json();
  } catch (error) {
    console.error('An unexpected error occurred during fetch:', error);
    // Re-throw or handle as appropriate for the application flow
    throw error; // Or throw new CustomError('Could not retrieve data', { cause: error });
  }
}

// Bad example: Swallowing error
async function badFetchData(url: string) {
  try {
    const response = await fetch(url);
    return await response.json();
  } catch (error) {
    // Error is swallowed, caller won't know something went wrong
    // and no logs are produced here.
    return null; 
  }
}
```
