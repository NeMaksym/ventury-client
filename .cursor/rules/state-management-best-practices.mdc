---
description: Guidelines for managing state in the React application.
globs: src/**/*.tsx
alwaysApply: false
---

# State Management Best Practices

Effective state management is crucial for a scalable and maintainable React application.

1.  **Local Component State (`useState`)**:
    *   Use `useState` for state that is local to a single component and doesn't need to be shared.
    *   Keep local state simple. If it becomes complex or needs to be shared, consider other solutions.

2.  **Shared State (`useReducer` or Lifting State Up)**:
    *   For more complex state logic within a component or closely related components, use `useReducer` for better organization and predictability.
    *   Lift state up to the nearest common ancestor when multiple sibling or child components need to share and manipulate the same state.

3.  **Context API (`useContext`)**:
    *   Use `useContext` for global state or state that needs to be passed down through many levels of the component tree (to avoid prop drilling).
    *   Be mindful of performance: components consuming a context will re-render when the context value changes. Optimize by splitting contexts or using `React.memo` on consumers where appropriate.
    *   Keep context values stable. Avoid passing new object/array references on every render if the underlying data hasn't changed, as this will cause unnecessary re-renders of consuming components.
        ```typescript
        // Good: Memoize context value if it's an object/array
        const contextValue = useMemo(() => ({ theme, toggleTheme }), [theme, toggleTheme]);
        return <ThemeContext.Provider value={contextValue}>{children}</ThemeContext.Provider>;
        ```

4.  **Derived State**:
    *   Avoid storing state that can be easily derived from other state or props. Calculate it during rendering instead.
    *   If the calculation is expensive, use `useMemo`.

5.  **Server State / Data Fetching State**:
    *   For managing state related to data fetching (loading, error, data), consider using dedicated libraries like React Query (TanStack Query) or SWR. These libraries provide caching, background updates, optimistic updates, and more, out-of-the-box.
    *   If not using a library, encapsulate data fetching logic in custom hooks.

6.  **Immutability**:
    *   When updating state (especially objects and arrays), always create new instances instead of mutating the existing ones directly. This is crucial for React's change detection and helps prevent bugs.
    ```typescript
    // Good: Updating an array immutably
    setItems(prevItems => [...prevItems, newItem]);
    // Good: Updating an object immutably
    setUser(prevUser => ({ ...prevUser, name: newName }));
    ```

7.  **Global State Management Libraries (Redux, Zustand, Jotai, etc.)**:
    *   For very large applications with complex, widespread state, consider a dedicated global state management library.
    *   Evaluate the trade-offs (boilerplate, learning curve) before introducing one. Often, a combination of local state, context, and server state libraries is sufficient.

**General Guidelines**:
- Choose the simplest state management solution that meets the requirements.
- Co-locate state with the components that use it as much as possible.
- Be consistent with your chosen patterns across the application. 