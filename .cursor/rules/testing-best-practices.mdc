---
description: Guidelines for writing effective tests in the project.
globs: src/**/*.spec.ts
alwaysApply: false
---

# Testing Best Practices

Comprehensive testing ensures code quality, maintainability, and reduces regressions.

1.  **Test Coverage**:
    *   Aim for a reasonable level of test coverage. Focus on testing critical paths, complex logic, and common user scenarios.
    *   100% coverage is not always practical or indicative of good tests, but strive to cover important functionality.

2.  **Types of Tests**:
    *   **Unit Tests**: Test individual functions, components, or modules in isolation. Mock dependencies to focus on the unit under test.
        *   *Tools*: Jest, Vitest, React Testing Library (for components).
    *   **Integration Tests**: Test the interaction between multiple components or modules. Ensure they work together as expected.
        *   *Tools*: React Testing Library, Jest, Vitest (with less mocking than unit tests).
    *   **End-to-End (E2E) Tests**: Test the entire application flow from the user's perspective. Simulate user interactions in a browser.
        *   *Tools*: Cypress, Playwright.

3.  **Write Clear and Readable Tests**:
    *   Use descriptive names for test suites (`describe` blocks) and individual tests (`it` or `test` blocks).
    *   Follow the Arrange-Act-Assert (AAA) pattern:
        *   **Arrange**: Set up the necessary preconditions and inputs.
        *   **Act**: Execute the code or function being tested.
        *   **Assert**: Verify that the outcome is as expected.
    *   Keep tests concise and focused on a single behavior or outcome.

4.  **Independent Tests**:
    *   Tests should be independent of each other. The outcome of one test should not affect another.
    *   Avoid relying on a shared mutable state between tests. Reset state before or after each test if necessary.

5.  **Test the Interface, Not the Implementation**:
    *   Focus on testing the public API or observable behavior of a module/component, not its internal implementation details.
    *   This makes tests more resilient to refactoring.
    *   For React components, test what the user sees and interacts with (using tools like React Testing Library).

6.  **Mocking and Spying**:
    *   Use mocks and spies judiciously to isolate units of code and to control external dependencies (e.g., API calls, timers).
    *   Avoid over-mocking, as it can lead to brittle tests that don't reflect real-world usage.
    *   *Tools*: Jest/Vitest built-in mocking capabilities.

7.  **Test Data**:
    *   Use realistic and varied test data, including edge cases, empty values, and invalid inputs.
    *   Consider using factories or fixtures to generate test data consistently.

8.  **Run Tests Frequently**:
    *   Integrate tests into your development workflow. Run them before committing or pushing code.
    *   Set up Continuous Integration (CI) to run tests automatically on every change.

Example (React Component Unit Test with React Testing Library & Jest/Vitest):
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import MyComponent from './MyComponent';

describe('MyComponent', () => {
  it('should render the initial message', () => {
    // Arrange
    render(<MyComponent initialMessage="Hello" />);
    
    // Act (implicit, component renders)
    
    // Assert
    expect(screen.getByText('Hello')).toBeInTheDocument();
  });

  it('should update the message on button click', () => {
    // Arrange
    render(<MyComponent initialMessage="Hello" />);
    const button = screen.getByRole('button', { name: /update message/i });
    
    // Act
    fireEvent.click(button);
    
    // Assert
    expect(screen.getByText('Message Updated!')).toBeInTheDocument();
    expect(screen.queryByText('Hello')).not.toBeInTheDocument();
  });
}); 